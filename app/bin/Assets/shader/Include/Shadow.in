precision highp float;

const vec2 Poisson25[25] = vec2[](
    vec2(-0.978698, -0.0884121),
    vec2(-0.841121, 0.521165),
    vec2(-0.71746, -0.50322),
    vec2(-0.702933, 0.903134),
    vec2(-0.663198, 0.15482),
    vec2(-0.495102, -0.232887),
    vec2(-0.364238, -0.961791),
    vec2(-0.345866, -0.564379),
    vec2(-0.325663, 0.64037),
    vec2(-0.182714, 0.321329),
    vec2(-0.142613, -0.0227363),
    vec2(-0.0564287, -0.36729),
    vec2(-0.0185858, 0.918882),
    vec2(0.0381787, -0.728996),
    vec2(0.16599, 0.093112),
    vec2(0.253639, 0.719535),
    vec2(0.369549, -0.655019),
    vec2(0.423627, 0.429975),
    vec2(0.530747, -0.364971),
    vec2(0.566027, -0.940489),
    vec2(0.639332, 0.0284127),
    vec2(0.652089, 0.669668),
    vec2(0.773797, 0.345012),
    vec2(0.968871, 0.840449),
    vec2(0.991882, -0.657338)
);

float bias_z(float z, vec2 dz_duv, vec2 offset)
{
    return z + dot(dz_duv, offset);
}

float linear_filter(highp sampler2D shadow_texture, vec2 uv)
{
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
    {
        return 1.0;
    }
    else
    {
        return texture(shadow_texture, uv).r;
    }
}

float poisson_filter(highp sampler2D shadow_texture, float z, vec2 uv, vec2 dz_duv, vec2 filter_radius, float shadow_z_bias)
{
    float shadow = 0.0;
    for (int i = 0; i < 25; ++i)
    {
        vec2 offset = Poisson25[i] * filter_radius;
        float shadow_depth = linear_filter(shadow_texture, uv + offset);
        if (bias_z(z, dz_duv, offset) - shadow_z_bias > shadow_depth)
        {
            shadow += 1.0;
        }
    }
    return shadow / 25.0;
}

vec2 depth_gradient(vec2 uv, float z)
{
    vec2 dz_duv = vec2(0.0, 0.0);

    vec3 duvdist_dx = dFdx(vec3(uv,z));
    vec3 duvdist_dy = dFdy(vec3(uv,z));

    dz_duv.x = duvdist_dy.y * duvdist_dx.z;
    dz_duv.x -= duvdist_dx.y * duvdist_dy.z;

    dz_duv.y = duvdist_dx.x * duvdist_dy.z;
    dz_duv.y -= duvdist_dy.x * duvdist_dx.z;

    float det = (duvdist_dx.x * duvdist_dy.y) - (duvdist_dx.y * duvdist_dy.x);
    dz_duv /= det;

    return dz_duv;
}

float sample_shadow(highp sampler2D shadow_texture, vec4 pos_light_proj, float shadow_filter_radius, float shadow_z_bias)
{
    vec2 uv = pos_light_proj.xy * 0.5 + 0.5;
    uv.y = 1.0 - uv.y;
    float z = pos_light_proj.z * 0.5 + 0.5;
    vec2 filter_radius = vec2(shadow_filter_radius);
    vec2 dz_duv = depth_gradient(uv, z);

    return poisson_filter(shadow_texture, z, uv, dz_duv, filter_radius, shadow_z_bias);
}
